{% extends "layout.html" %}

{% block title %}{{ _('Scanner') }}{% endblock %}

{% block head_extra %}
<!-- ZXing library for barcode scanning (DataMatrix, EAN, PZN/Code39, etc.) -->
<script src="https://unpkg.com/@zxing/library@latest/umd/index.min.js"></script>
<style>
    #scanner-video {
        width: 100%;
        max-width: 600px;
        height: auto;
        min-height: 450px; /* Typical 4:3 aspect ratio for 600px width */
        background: #000;
        border-radius: 8px;
        object-fit: cover; /* Ensure video fills the container */
    }
    .scanner-container {
        position: relative;
        display: inline-block;
        width: 100%;
        max-width: 600px;
        min-height: 450px; /* Prevent container resize on camera load */
        overflow: hidden;
        border-radius: 8px;
        background: #000; /* Black background while loading */
    }
    /* Loading spinner for camera initialization */
    .camera-loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 48px;
        z-index: 5;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        from { transform: translate(-50%, -50%) rotate(0deg); }
        to { transform: translate(-50%, -50%) rotate(360deg); }
    }
    .scanner-container.camera-ready .camera-loading {
        display: none;
    }
    /* Top blur overlay */
    .blur-top {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: calc(50% - 60px); /* Linear: half of 120px */
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        pointer-events: none;
        z-index: 10;
        opacity: 0; /* Hidden initially */
        transition: height 0.3s ease, opacity 0.5s ease;
    }

    /* Bottom blur overlay */
    .blur-bottom {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: calc(50% - 60px); /* Linear: half of 120px */
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        pointer-events: none;
        z-index: 10;
        opacity: 0; /* Hidden initially */
        transition: height 0.3s ease, opacity 0.5s ease;
    }

    /* Left blur overlay */
    .blur-left {
        position: absolute;
        top: calc(50% - 60px);
        left: 0;
        width: 10%; /* Linear: (100% - 80%) / 2 */
        height: 120px;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        pointer-events: none;
        z-index: 10;
        opacity: 0; /* Hidden initially */
        transition: all 0.3s ease, opacity 0.5s ease;
    }

    /* Right blur overlay */
    .blur-right {
        position: absolute;
        top: calc(50% - 60px);
        right: 0;
        width: 10%; /* Linear: (100% - 80%) / 2 */
        height: 120px;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        pointer-events: none;
        z-index: 10;
        opacity: 0; /* Hidden initially */
        transition: all 0.3s ease, opacity 0.5s ease;
    }
    
    /* Show blur overlays when camera is ready */
    .scanner-container.camera-ready .blur-top,
    .scanner-container.camera-ready .blur-bottom,
    .scanner-container.camera-ready .blur-left,
    .scanner-container.camera-ready .blur-right {
        opacity: 1;
    }

    /* DataMatrix mode adjustments */
    .scanner-container.datamatrix-active .blur-top {
        height: calc(50% - 125px); /* Half of 250px */
    }
    .scanner-container.datamatrix-active .blur-bottom {
        height: calc(50% - 125px); /* Half of 250px */
    }
    .scanner-container.datamatrix-active .blur-left {
        top: calc(50% - 125px);
        width: calc(50% - 125px);
        height: 250px;
    }
    .scanner-container.datamatrix-active .blur-right {
        top: calc(50% - 125px);
        width: calc(50% - 125px);
        height: 250px;
    }
    /* Linear mode: 80% width (max 400px), 120px height */
    .scan-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        height: 120px;
        pointer-events: none;
        z-index: 11;
        transition: all 0.3s ease;
    }
    /* Square frame for DataMatrix mode */
    .scan-indicator.datamatrix-mode {
        width: 250px;
        height: 250px;
    }
    /* Barcode scanner frame */
    .scan-indicator::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 2px solid rgba(255, 255, 255, 0.8);
        border-radius: 4px;
        box-shadow:
            inset 0 0 0 4px rgba(0, 0, 0, 0.3),
            0 0 20px rgba(0, 0, 0, 0.5);
    }
    /* Red scanning line */
    .scan-line {
        position: absolute;
        top: 50%;
        left: 5%;
        right: 5%;
        height: 2px;
        background: linear-gradient(90deg,
            transparent 0%,
            rgba(255, 0, 0, 0.5) 20%,
            rgba(255, 0, 0, 1) 50%,
            rgba(255, 0, 0, 0.5) 80%,
            transparent 100%
        );
        box-shadow: 0 0 8px rgba(255, 0, 0, 0.8);
        transform: translateY(-50%);
        opacity: 0; /* Hidden by default */
        animation: none; /* No animation initially */
    }
    /* Show and animate the scan line when camera is ready */
    .scanner-container.camera-ready .scan-line {
        opacity: 1;
        animation: scan 2s linear infinite;
    }
    @keyframes scan {
        0% {
            top: 10%;
            opacity: 0;
        }
        10% {
            opacity: 1;
        }
        90% {
            opacity: 1;
        }
        100% {
            top: 90%;
            opacity: 0;
        }
    }
    .mode-toggle {
        display: inline-flex;
        border-radius: 6px;
        overflow: hidden;
        border: 1px solid #dee2e6;
        background: white;
    }
    .mode-toggle input[type="radio"] {
        display: none;
    }
    .mode-toggle label {
        padding: 6px 12px;
        cursor: pointer;
        background: transparent;
        color: #6c757d;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        font-size: 0.9rem;
    }
    .mode-toggle label:hover {
        background: #f8f9fa;
    }
    .mode-toggle input[type="radio"]:checked + label {
        background: #007bff;
        color: white;
    }
    .scan-result {
        margin-top: 20px;
        padding: 15px;
        border-radius: 8px;
        display: none;
    }
    .scan-result.success {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
    }
    .scan-result.error {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
    }
    /* Camera control buttons */
    #switch-camera-btn, #toggle-torch-btn {
        position: absolute;
        bottom: 20px;
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        border: none;
        font-size: 20px;
        display: none;
        z-index: 12;
        cursor: pointer;
        transition: background 0.2s;
    }
    #switch-camera-btn {
        right: 20px;
    }
    #toggle-torch-btn {
        left: 20px;
    }
    #switch-camera-btn:hover, #toggle-torch-btn:hover {
        background: rgba(0, 0, 0, 0.8);
    }
    #switch-camera-btn:active, #toggle-torch-btn:active {
        transform: scale(0.95);
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <div class="row justify-content-center">
        <div class="col-lg-8">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">{{ _('Scanner') }}</h5>
                    <div class="d-flex align-items-center gap-3">
                        <!-- Mode selection -->
                        <div class="mode-toggle">
                            <input type="radio" id="mode-datamatrix" name="scan-mode" value="datamatrix" checked>
                            <label for="mode-datamatrix" title="{{ _('DataMatrix codes') }}">
                                <i class="fas fa-qrcode"></i>
                            </label>
                            <input type="radio" id="mode-linear" name="scan-mode" value="linear">
                            <label for="mode-linear" title="{{ _('Linear barcodes (EAN, PZN)') }}">
                                <i class="fas fa-barcode"></i>
                            </label>
                        </div>
                        <span id="scan-status" class="badge bg-secondary">{{ _('Initializing...') }}</span>
                    </div>
                </div>
                <div class="card-body text-center">
                    <!-- Camera view with overlay -->
                    <div class="scanner-container" id="scanner-container">
                        <!-- Loading spinner -->
                        <div class="camera-loading">
                            <i class="fas fa-spinner"></i>
                        </div>
                        <video id="scanner-video" autoplay muted playsinline></video>
                        <!-- Blur overlays for areas outside scanning area -->
                        <div class="blur-top"></div>
                        <div class="blur-bottom"></div>
                        <div class="blur-left"></div>
                        <div class="blur-right"></div>
                        <!-- Scanning indicator -->
                        <div class="scan-indicator" id="scan-indicator">
                            <div class="scan-line"></div>
                        </div>
                        <!-- Torch/Light button (left) -->
                        <button id="toggle-torch-btn" aria-label="Toggle Light">
                            <i class="fas fa-lightbulb"></i>
                        </button>
                        <!-- Camera switch button (right) -->
                        <button id="switch-camera-btn" onclick="switchCamera()" aria-label="Switch Camera">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>

                    <!-- Scan result display -->
                    <div id="scan-result" class="scan-result"></div>

                    <!-- Controls -->
                    <div class="mt-3">
                        <button class="btn btn-sm btn-primary d-none" id="retry-camera-btn">
                            <i class="fas fa-camera"></i> {{ _('Retry') }}
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
let codeReader = null;
let videoStream = null;
let selectedDeviceId = null;
let isScanning = false;
let lastScannedCode = null;
let lastScannedTime = 0;
let currentMode = 'datamatrix';
let torchSupported = false;
let isInitializing = false; // Prevent concurrent initializations

// Initialize and start immediately
document.addEventListener('DOMContentLoaded', () => {
    if (typeof ZXing === 'undefined') {
        console.error('ZXing library not loaded');
        showStatus('{{ _("Scanner error") }}', 'danger');
        return;
    }

    // Initialize with datamatrix mode as default
    document.getElementById('scan-indicator').classList.add('datamatrix-mode');
    document.querySelector('.scanner-container').classList.add('datamatrix-active');
    initializeScanner('datamatrix');
    startScanning();

    // Mode switching
    document.querySelectorAll('input[name="scan-mode"]').forEach(radio => {
        radio.addEventListener('change', async (e) => {
            if (isInitializing) {
                console.log('Already initializing, ignoring mode change');
                return;
            }
            
            currentMode = e.target.value;
            console.log('Switching to mode:', currentMode);

            // Update UI for mode
            const scanIndicator = document.getElementById('scan-indicator');
            const scannerContainer = document.querySelector('.scanner-container');
            
            // Remove camera-ready class to hide scan line while reinitializing
            scannerContainer.classList.remove('camera-ready');

            if (currentMode === 'datamatrix') {
                scanIndicator.classList.add('datamatrix-mode');
                scannerContainer.classList.add('datamatrix-active');
            } else {
                scanIndicator.classList.remove('datamatrix-mode');
                scannerContainer.classList.remove('datamatrix-active');
            }

            // Store the current camera selection before stopping
            const preservedDeviceId = selectedDeviceId;
            console.log('Preserving camera device ID:', preservedDeviceId);
            
            // Stop current scanning and video stream completely
            isInitializing = true;
            await stopScanning();
            
            // Reinitialize with new mode
            initializeScanner(currentMode);

            // Restore the camera selection
            selectedDeviceId = preservedDeviceId;
            console.log('Restored camera device ID:', selectedDeviceId);
            
            // Restart scanning with preserved camera
            // Add delay to ensure iOS properly releases camera
            setTimeout(async () => {
                await startScanning();
                isInitializing = false;
            }, 300);
        });
    });
});

function initializeScanner(mode) {
    // Stop and clean up existing reader completely before creating new one
    if (codeReader) {
        try {
            codeReader.reset();
            // Small delay to ensure cleanup on iOS
            codeReader = null;
        } catch (e) {
            console.log('Error resetting reader:', e);
        }
    }
    
    const hints = new Map();

    if (mode === 'datamatrix') {
        // Optimize for DataMatrix/2D codes
        hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
        hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [
            ZXing.BarcodeFormat.DATA_MATRIX
            // ZXing.BarcodeFormat.QR_CODE,
            // ZXing.BarcodeFormat.AZTEC
        ]);
        codeReader = new ZXing.BrowserMultiFormatReader(hints);
        console.log('Scanner optimized for DataMatrix/2D codes');
    } else {
        // Optimize for linear barcodes (PZN, EAN, etc.)
        hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [
            ZXing.BarcodeFormat.CODE_39,      // PZN
            // ZXing.BarcodeFormat.CODE_128,
            ZXing.BarcodeFormat.EAN_13       // Standard retail
            // ZXing.BarcodeFormat.EAN_8,
            // ZXing.BarcodeFormat.UPC_A,
            // ZXing.BarcodeFormat.UPC_E
        ]);
        codeReader = new ZXing.BrowserMultiFormatReader(hints);
        console.log('Scanner optimized for linear barcodes');
    }
}

async function startScanning() {
    if (isScanning) return;

    try {
        showStatus('{{ _("Starting camera...") }}', 'warning');

        // Detect iOS Chrome
        const isIOSChrome = /CriOS/.test(navigator.userAgent) || 
                           (/iPhone|iPad|iPod/.test(navigator.userAgent) && /Chrome/.test(navigator.userAgent));
        
        if (isIOSChrome) {
            console.log('iOS Chrome detected, using special handling');
        }

        // Get available video devices
        const videoInputDevices = await codeReader.listVideoInputDevices();

        if (videoInputDevices.length === 0) {
            showStatus('{{ _("No camera found") }}', 'danger');
            document.getElementById('retry-camera-btn').classList.remove('d-none');
            return;
        }

        // Store available devices globally for camera switching
        window.videoDevices = videoInputDevices;
        
        // Show camera switch button if multiple cameras
        if (videoInputDevices.length > 1) {
            document.getElementById('switch-camera-btn').style.display = 'block';
        }

        // Debug: Log all available cameras
        console.log('Available cameras:', videoInputDevices.map(d => ({
            id: d.deviceId,
            label: d.label
        })));
        
        // Use previously selected device if available, otherwise select rear camera
        if (!selectedDeviceId) {
            console.log('No previous camera selected, finding back camera...');
            
            // Check localStorage for saved preference
            const savedDeviceId = localStorage.getItem('preferredCameraId');
            if (savedDeviceId && videoInputDevices.some(d => d.deviceId === savedDeviceId)) {
                selectedDeviceId = savedDeviceId;
                console.log('Using saved camera preference:', selectedDeviceId);
            } else {
                // On first load, try to find back camera
                selectedDeviceId = videoInputDevices[0].deviceId;
                
                // Try to identify back camera by label
                for (const device of videoInputDevices) {
                    const label = device.label.toLowerCase();
                    if (label.includes('back') ||
                        label.includes('environment') ||
                        label.includes('rear') ||
                        label.includes('posteriore') || // Italian
                        label.includes('arrière') || // French
                        label.includes('trasera') || // Spanish
                        label.includes('hinten') || // German
                        label.includes('后置')) { // Chinese
                        selectedDeviceId = device.deviceId;
                        console.log('Selected back camera by label:', device.label);
                        break;
                    }
                }
                
                // If we have multiple cameras and couldn't identify back camera,
                // assume the last one is the back camera (common pattern on iOS)
                if (videoInputDevices.length > 1 && 
                    selectedDeviceId === videoInputDevices[0].deviceId &&
                    !videoInputDevices[0].label.toLowerCase().includes('back')) {
                    selectedDeviceId = videoInputDevices[videoInputDevices.length - 1].deviceId;
                    console.log('Selected last camera as likely back camera');
                }
                
                // Save the selection
                localStorage.setItem('preferredCameraId', selectedDeviceId);
            }
        } else {
            console.log('Using previously selected camera:', selectedDeviceId);
            // Update saved preference
            localStorage.setItem('preferredCameraId', selectedDeviceId);
        }

        console.log('Starting continuous scanning with device:', selectedDeviceId);
        isScanning = true;
        showStatus('{{ _("Scanning...") }}', 'success');
        
        // isIOSChrome already declared above
        let decodingStream;
        
        if (isIOSChrome && videoInputDevices.length > 1) {
            // Try to use constraints instead of device ID for iOS Chrome
            try {
                console.log('Using constraints-based approach for iOS Chrome');
                
                // Determine if we want front or back camera based on device selection
                const currentDeviceIndex = videoInputDevices.findIndex(d => d.deviceId === selectedDeviceId);
                const wantsFrontCamera = currentDeviceIndex === 0 && videoInputDevices.length > 1;
                
                const constraints = {
                    video: {
                        facingMode: wantsFrontCamera ? 'user' : { ideal: 'environment' }
                    }
                };
                
                console.log('Requesting camera with constraints:', constraints);
                
                // Get stream manually first
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                const videoElement = document.getElementById('scanner-video');
                videoElement.srcObject = stream;
                videoStream = stream;
                
                // Then use ZXing with the element
                await codeReader.decodeFromVideoElement(videoElement, (result, err) => {
                    handleScanResult(result, err);
                });
                
            } catch (e) {
                console.log('Constraints-based approach failed, falling back to device ID:', e);
                // Fall back to regular approach
                decodingStream = await codeReader.decodeFromVideoDevice(selectedDeviceId, 'scanner-video', (result, err) => {
                    handleScanResult(result, err);
                });
            }
        } else {
            // Regular approach for non-iOS Chrome
            decodingStream = await codeReader.decodeFromVideoDevice(selectedDeviceId, 'scanner-video', (result, err) => {
                handleScanResult(result, err);
            });
        }

    } catch (err) {
        showStatus('{{ _("Camera error") }}', 'danger');
        document.getElementById('retry-camera-btn').classList.remove('d-none');
        console.error(err);
        isScanning = false;
    }
}

function handleScanResult(result, err) {
    // Mark container as ready on first frame (removes loading spinner)
    if (!document.getElementById('scanner-container').classList.contains('camera-ready')) {
        document.getElementById('scanner-container').classList.add('camera-ready');
    }
    if (result) {
        const now = Date.now();
        // Debounce: Don't scan same code within 2 seconds
        if (result.text !== lastScannedCode || now - lastScannedTime > 2000) {
            console.log('Barcode detected:', result.text);
            lastScannedCode = result.text;
            lastScannedTime = now;

            // Use requestAnimationFrame for smoother UI updates
            requestAnimationFrame(() => {
                flashScanIndicator();
                processScan(result.text);
            });
        }
    }

    // Silently ignore NotFoundException - it's normal when no code is visible
    if (err && !(err instanceof ZXing.NotFoundException)) {
        console.debug('Scan error:', err.message);
    }
    
    // Get the video stream for torch control if not already set
    if (!videoStream) {
        const videoElement = document.getElementById('scanner-video');
        if (videoElement.srcObject) {
            videoStream = videoElement.srcObject;
            const track = videoStream.getVideoTracks()[0];
            const capabilities = track.getCapabilities ? track.getCapabilities() : {};
            if (capabilities.torch) {
                torchSupported = true;
                document.getElementById('toggle-torch-btn').style.display = 'block';
            }
        }
    }
}


function flashScanIndicator() {
    const scanLine = document.querySelector('.scan-line');
    const scanIndicator = document.querySelector('.scan-indicator');

    // Flash the scan line to green
    scanLine.style.background = 'linear-gradient(90deg, transparent 0%, rgba(0, 255, 0, 0.5) 20%, rgba(0, 255, 0, 1) 50%, rgba(0, 255, 0, 0.5) 80%, transparent 100%)';
    scanLine.style.boxShadow = '0 0 20px rgba(0, 255, 0, 1)';
    scanLine.style.height = '4px';

    // Flash the frame border
    scanIndicator.style.borderColor = 'rgba(0, 255, 0, 0.8)';
    scanIndicator.style.boxShadow = '0 0 30px rgba(0, 255, 0, 0.6)';

    // Reset after animation
    setTimeout(() => {
        scanLine.style.background = 'linear-gradient(90deg, transparent 0%, rgba(255, 0, 0, 0.5) 20%, rgba(255, 0, 0, 1) 50%, rgba(255, 0, 0, 0.5) 80%, transparent 100%)';
        scanLine.style.boxShadow = '0 0 8px rgba(255, 0, 0, 0.8)';
        scanLine.style.height = '2px';

        scanIndicator.style.borderColor = '';
        scanIndicator.style.boxShadow = '';
    }, 300);
}

// Switch camera function
function switchCamera() {
    if (!window.videoDevices || window.videoDevices.length < 2) return;
    
    // Find current device index
    let currentIndex = window.videoDevices.findIndex(device => device.deviceId === selectedDeviceId);
    
    // Switch to next camera
    currentIndex = (currentIndex + 1) % window.videoDevices.length;
    selectedDeviceId = window.videoDevices[currentIndex].deviceId;
    
    console.log('Switching to camera:', window.videoDevices[currentIndex].label || 'Camera ' + currentIndex);
    
    // Save the new selection
    localStorage.setItem('preferredCameraId', selectedDeviceId);
    
    // Stop current scanning
    if (codeReader) {
        codeReader.reset();
    }
    
    // Remove camera-ready class to show loading state
    document.getElementById('scanner-container').classList.remove('camera-ready');
    
    // Restart with new camera
    isScanning = false;
    setTimeout(() => startScanning(), 100);
}

// Toggle torch/flashlight
document.getElementById('toggle-torch-btn').addEventListener('click', async () => {
    if (!videoStream || !torchSupported) return;

    const track = videoStream.getVideoTracks()[0];
    const constraints = track.getConstraints();

    try {
        await track.applyConstraints({
            torch: !constraints.torch
        });
    } catch (err) {
        console.error('Failed to toggle torch:', err);
    }
});

document.getElementById('retry-camera-btn').addEventListener('click', () => {
    document.getElementById('retry-camera-btn').classList.add('d-none');
    stopScanning();
    startScanning();
});

async function processScan(barcodeData) {
    // Ignore very short codes (likely misreads)
    if (barcodeData.length < 4) {
        console.log('Ignoring short code:', barcodeData);
        return;
    }

    // Ignore single characters or obvious misreads
    if (barcodeData.length === 1 || (barcodeData.length < 6 && !barcodeData.match(/^\d+$/))) {
        console.log('Ignoring likely misread:', barcodeData);
        return;
    }

    try {
        const response = await fetch('{{ url_for("scanner.scan") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                barcode: barcodeData
            })
        });

        const result = await response.json();
        const resultDiv = document.getElementById('scan-result');

        if (response.ok) {
            // Show success message
            let message = '<strong>' + (result.medication ? result.medication.name : '{{ _("Scanned successfully") }}') + '</strong>';
            if (result.parsed_data) {
                if (result.parsed_data.national_number) {
                    message += '<br><small>PZN: ' + result.parsed_data.national_number + '</small>';
                }
                if (result.parsed_data.batch) {
                    message += '<br><small>{{ _("Batch") }}: ' + result.parsed_data.batch + '</small>';
                }
                if (result.parsed_data.expiry) {
                    message += '<br><small>{{ _("Expiry") }}: ' + new Date(result.parsed_data.expiry).toLocaleDateString() + '</small>';
                }
            }

            resultDiv.innerHTML = message;
            resultDiv.className = 'scan-result success';
            resultDiv.style.display = 'block';

            // Hide after 5 seconds
            setTimeout(() => {
                resultDiv.style.display = 'none';
            }, 5000);
        } else {
            // Show error message
            let errorMessage = '<strong>' + result.error + '</strong>';
            if (result.hint) {
                errorMessage += '<br><small>' + result.hint + '</small>';
            }

            resultDiv.innerHTML = errorMessage;
            resultDiv.className = 'scan-result error';
            resultDiv.style.display = 'block';

            // Hide after 3 seconds
            setTimeout(() => {
                resultDiv.style.display = 'none';
            }, 3000);
        }
    } catch (err) {
        console.log('Scan processing failed:', barcodeData);
    }
}


function showStatus(message, type) {
    const statusBadge = document.getElementById('scan-status');
    statusBadge.textContent = message;
    statusBadge.className = 'badge bg-' + type;
}

async function stopScanning() {
    isScanning = false;

    // Stop video stream
    if (videoStream) {
        console.log('Stopping video stream...');
        videoStream.getTracks().forEach(track => {
            track.stop();
            console.log('Stopped track:', track.kind, track.label);
        });
        videoStream = null;
    }

    // Reset code reader
    if (codeReader) {
        try {
            console.log('Resetting code reader...');
            codeReader.reset();
        } catch (e) {
            console.log('Error resetting reader:', e);
        }
    }
    
    // Small delay to ensure iOS releases camera
    await new Promise(resolve => setTimeout(resolve, 100));
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    stopScanning();
});
</script>
{% endblock %}